"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetUserStats = void 0;
const apiClient_1 = require("./apiClient");
const auth_1 = require("./auth");
const constants_1 = require("../constants");
const getUserByUserId_1 = require("./getUserByUserId");
const GetUserStats = async (userId, platform, view, aggregation, gameMode, teamRole, season) => {
    if (!userId || !platform || !view || !aggregation || !gameMode || !teamRole || !season)
        throw new Error(`Please check userId: ${userId}, platform: ${platform}, view: ${view}, aggregation: ${aggregation}, gameMode: ${gameMode}, teamRole: ${teamRole}, season: ${season}`);
    const token = await (0, auth_1.CheckToken)();
    const experation = await (0, auth_1.GetExperation)();
    const headers = {
        Authorization: `ubi_v1 t=${token}`,
        'Ubi-SessionId': constants_1.UBI_DATADEV_SESSIONID,
        'Content-Type': 'application/json',
        expiration: experation,
    };
    const user = await (0, getUserByUserId_1.GetUserByUserId)(userId);
    const platformTransformation = platform === 'uplay' ? 'PC' : 'CONSOLE';
    const spaceId = constants_1.RANKED_UBI_SPACEIDS.find(x => x.id === platformTransformation)?.value;
    if (spaceId === '')
        throw new Error('SpaceId was not found');
    const URI = constants_1.UBI_DATADEV_URI +
        (0, constants_1.UBI_GETSTATS)(userId, spaceId, platformTransformation, view, aggregation, gameMode, teamRole, season);
    const response = await (0, apiClient_1.ApiClient)(URI, headers, 'GET');
    const usersStats = await BuildUserStats(await response, user, platformTransformation, platform);
    return usersStats;
};
exports.GetUserStats = GetUserStats;
const BuildUserStats = async (data, user, plaform, originalPlatform) => {
    const stats = {
        all: {},
        ranked: {},
        unranked: {},
        casual: {},
    };
    const id = originalPlatform === 'psn'
        ? user.find(x => x.platformType == originalPlatform)?.profileId ?? ''
        : user[0].userId;
    const ranked = data.profileData[id].platforms[plaform].gameModes.ranked;
    const unranked = data.profileData[id].platforms[plaform].gameModes.unranked;
    const all = data.profileData[id].platforms[plaform].gameModes.all;
    const casual = data.profileData[id].platforms[plaform].gameModes.casual;
    if (all !== undefined) {
        stats.all = await BuildStats(all);
    }
    if (ranked !== undefined) {
        stats.ranked = await BuildStats(ranked);
    }
    if (unranked !== undefined) {
        stats.unranked = await BuildStats(unranked);
    }
    if (casual !== undefined) {
        stats.casual = await BuildStats(casual);
    }
    return stats;
};
const BuildStats = async (gameMode) => {
    const roles = {};
    const teamRoles = gameMode.teamRoles;
    if (Array.isArray(teamRoles.all) && teamRoles.all.length > 0) {
        roles.all = await MapStats(teamRoles.all[0]);
    }
    if (Array.isArray(teamRoles.Attacker) && teamRoles.Attacker.length > 0) {
        roles.attackers = await MapStats(teamRoles.Attacker[0]);
    }
    if (Array.isArray(teamRoles.Defender) && teamRoles.Defender.length > 0) {
        roles.defenders = await MapStats(teamRoles.Defender[0]);
    }
    return roles;
};
const MapStats = async (stat) => {
    const stats = {
        type: stat.type,
        statsType: stat.statsType,
        statsDetail: stat.statsDetail,
        seasonYear: stat.seasonYear,
        seasonNumber: stat.seasonNumber,
        matchesPlayed: stat.matchesPlayed,
        roundsPlayed: stat.roundsPlayed,
        minutesPlayed: stat.minutesPlayed,
        matchesWon: stat.matchesWon,
        matchesLost: stat.matchesLost,
        roundsWon: stat.roundsWon,
        roundsLost: stat.roundsLost,
        kills: stat.kills,
        assists: stat.assists,
        deaths: stat.death,
        headshots: stat.headshots,
        meleeKills: stat.meleeKills,
        teamKills: stat.teamKills,
        openingKills: stat.openingKills,
        openingDeaths: stat.openingDeaths,
        trades: stat.trades,
        openingKillTrades: stat.openingKillTrades,
        openingDeathTrades: stat.openingDeathTrades,
        revives: stat.revives,
        distanceTravelled: stat.distanceTravelled,
        winLossRatio: stat.winLossRatio,
        killDeathRatio: stat.killDeathRatio.value,
        headshotAccuracy: stat.headshotAccuracy.value,
        killsPerRound: stat.killsPerRound.value,
        roundsWithAKill: stat.roundsWithAKill.value,
        roundsWithMultiKill: stat.roundsWithMultiKill.value,
        roundsWithOpeningKill: stat.roundsWithOpeningKill.value,
        roundsWithOpeningDeath: stat.roundsWithOpeningDeath.value,
        roundsWithKOST: stat.roundsWithKOST.value,
        roundsSurvived: stat.roundsSurvived.value,
        roundsWithAnAce: stat.roundsWithAnAce.value,
        roundsWithClutch: stat.roundsWithClutch.value,
        timeAlivePerMatch: stat.timeAlivePerMatch,
        timeDeadPerMatch: stat.timeDeadPerMatch,
        distancePerRound: stat.distancePerRound,
    };
    return stats;
};
//# sourceMappingURL=getUserStats.js.map